[[!meta title="Javascript Promises"]]

[Promises FAQ](https://gist.github.com/joepie91/4c3a10629a4263a522e3bc4839a28c83#12-how-do-i-access-previous-results-from-the-promise-chain)

[Promises with AWS](https://github.com/kaihendry/lambda-promises/)

# How do i implement a reject on a thrown error?

	return Promise.resolve().then(() => {
	  if (!isGood) throw new Error('a wrench')
	  return doneStuff
	})

# Refactoring example

Bad:

	function foo(data) {
		return new Promise((resolve, reject) => {
			console.log("debug data", data)
			let video = {}
			if (data.Item) {
				video = data.Item
			} else {
				video = data
			}
			console.log("debug video", video)
			resolve(video)
		})
	}

	foo({ id: 12, title: "Back to the future"})
	.then((output) => console.log(output))

Really bad (i.e. non-working) when using `const` btw!

Good:

	function foo (data) {
		return Promise.resolve().then(() => {
			console.log("debug data", data)
			return data.Item || data
		})
	}

Or event just:

	function foo (data) {
	  return Promise.resolve().then(() => data.Item || data)
	}

# const isn't that bad

From Tim Oxley: seems a shame to lose benefits of const due to conditional
initialisation. Instead of if/else + let I generally go for const + || in cases
like the above, or a ternary :

	// ternary
	const thing = someCondition ? valueIfTrue : valueIfFalse
	// multi-line conditional
	const thing = (
	  multi &&
	  line &&
	  conditional
	)
	? valueIfTrue
	: valueIfFalse
